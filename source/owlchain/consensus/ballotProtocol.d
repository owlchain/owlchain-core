module owlchain.consensus.ballotProtocol;

import core.time;

import std.stdio;
import std.container;
import std.conv;
import std.json;
import std.algorithm : canFind;
import std.algorithm : find;
import std.typecons;
import std.digest.sha;
import core.stdc.stdint;

import owlchain.xdr.type;
import owlchain.xdr.bcpStatement;
import owlchain.xdr.bcpStatementType;
import owlchain.xdr.hash;
import owlchain.xdr.bcpEnvelope;
import owlchain.xdr.value;
import owlchain.xdr.bcpQuorumSet;
import owlchain.xdr.nodeID;
import owlchain.xdr.bcpBallot;

import owlchain.consensus.bcp;
import owlchain.consensus.bcpDriver;
import owlchain.consensus.slot;
import owlchain.consensus.localNode;

import owlchain.utils.globalChecks;
import owlchain.utils.uniqueStruct;

alias Tuple!(uint32, "low", uint32, "high") Interval;
alias RedBlackTree!(uint32, "a < b") UInt32Set;

alias bool delegate(ref BCPStatement st) StatementPredicate;
alias bool delegate(ref Interval) IntervalPredicate;

alias RefCounted!(BCPEnvelope, RefCountedAutoInitialize.no) BCPEnvelopePtr;

static const int MAX_ADVANCESLOT_RECURSION = 50;

// human readable names matching BCPPhase
static const mPhaseNames = ["PREPARE", "FINISH", "EXTERNALIZE"];

class BallotProtocol
{
private:
    Slot mSlot;
    bool mHeardFromQuorum;

    // state tracking members
    enum BCPPhase
    {
        BCP_PHASE_PREPARE,
        BCP_PHASE_CONFIRM,
        BCP_PHASE_EXTERNALIZE,
        BCP_PHASE_NUM
    };

    UniqueStruct!BCPBallot mCurrentBallot; // b
    UniqueStruct!BCPBallot mPrepared; // p    
    UniqueStruct!BCPBallot mPreparedPrime; // p'
    UniqueStruct!BCPBallot mHighBallot; // h
    UniqueStruct!BCPBallot mCommit; // c
    BCPEnvelope[NodeID] mLatestEnvelopes; // M
    BCPPhase mPhase; // Phi
    int mCurrentMessageLevel; // number of messages triggered in one run
    BCPEnvelopePtr mLastEnvelope; // last envelope generated by this node
    BCPEnvelopePtr mLastEnvelopeEmit; // last envelope emitted by this node

public:

    this(Slot value)
    {
        mSlot = value;
        mHeardFromQuorum = true;
        mPhase = BCPPhase.BCP_PHASE_PREPARE;
        mCurrentMessageLevel = 0;
    }

    // Process a newly received envelope for this slot and update the state of
    // the slot accordingly.
    // self: set to true when node feeds its own statements in order to
    // trigger more potential state changes
    BCP.EnvelopeState processEnvelope(ref BCPEnvelope envelope, bool self)
    {
        BCP.EnvelopeState res = BCP.EnvelopeState.INVALID;
        dbgAssert(envelope.statement.slotIndex == mSlot.getSlotIndex());

        BCPStatement* statement = &envelope.statement;
        NodeID* nodeID = &statement.nodeID;

        if (!isStatementSane(*statement, self))
        {
            if (self)
            {
                writefln("[ERROR], BCP not sane statement from self, skipping   e: %s",
                        mSlot.getCP().envToStr(envelope));
            }
            return BCP.EnvelopeState.INVALID;
        }

        if (!isNewerStatement(*nodeID, *statement))
        {
            if (self)
            {
                writefln("[ERROR], BCP stale statement from self, skipping   e: %s",
                        mSlot.getCP().envToStr(envelope));
            }
            else
            {
                writefln("[TRACE], BCP stale statement, skipping   i: %d",
                        mSlot.getSlotIndex);
            }
            return BCP.EnvelopeState.INVALID;
        }

        auto validationRes = validateValues(*statement);
        if (validationRes != BCPDriver.ValidationLevel.kInvalidValue)
        {
            bool processed = false;

            if (mPhase != BCPPhase.BCP_PHASE_EXTERNALIZE)
            {
                if (validationRes == BCPDriver.ValidationLevel.kMaybeValidValue)
                {
                    mSlot.setFullyValidated(false);
                }

                recordEnvelope(envelope);
                processed = true;
                advanceSlot(*statement);
                res = BCP.EnvelopeState.VALID;
            }

            if (!processed)
            {
                // note: this handles also our own messages
                // in particular our final EXTERNALIZE message
                if (mPhase == BCPPhase.BCP_PHASE_EXTERNALIZE
                        && mCommit.value == getWorkingBallot(*statement).value)
                {
                    recordEnvelope(envelope);
                    res = BCP.EnvelopeState.VALID;
                }
                else
                {
                    if (self)
                    {
                        writefln("[ERROR], BCP externalize statement with invalid value from self, skipping   e: %s",
                                mSlot.getCP().envToStr(envelope));
                    }

                    res = BCP.EnvelopeState.INVALID;
                }
            }
        }
        else
        {
            // If the value is not valid, we just ignore it.
            if (self)
            {
                writefln("[ERROR], BCP invalid value from self, skipping   e: %s",
                        mSlot.getCP().envToStr(envelope));
            }
            else
            {
                writefln("[TRACE], BCP invalid value  i: %d", mSlot.getSlotIndex);
            }

            res = BCP.EnvelopeState.INVALID;
        }
        return res;
    }

    void ballotProtocolTimerExpired()
    {
        // don't abandon the ballot until we have heard from a slice
        if (mHeardFromQuorum)
        {
            abandonBallot(0);
        }
        else
        {
            writefln("[DEBUG], BCP Waiting to hear from a slice.");
            startBallotProtocolTimer();
        }
    }

    // abandon's current ballot, move to a new ballot
    // at counter `n` (or, if n == 0, increment current counter)
    bool abandonBallot(uint32 n)
    {
        //writefln("[DEBUG], BCP BallotProtocol.abandonBallot");
        bool res = false;
        Value v = mSlot.getLatestCompositeCandidate();
        if (v.value.length == 0)
        {
            if (mCurrentBallot)
            {
                v = mCurrentBallot.value;
            }
        }

        if (v.value.length != 0)
        {
            if (n == 0)
            {
                res = bumpState(v, true);
            }
            else
            {
                res = bumpState(v, n);
            }
        }
        return res;
    }

    // bumps the ballot based on the local state and the value passed in:
    // in prepare phase, attempts to take value
    // otherwise, no-ops
    // force: when true, always bumps the value, otherwise only bumps
    // the state if no value was prepared
    bool bumpState(ref Value value, bool force)
    {
        uint32 n;
        if (!force && mCurrentBallot)
        {
            return false;
        }

        BCPBallot newb;

        n = mCurrentBallot ? (mCurrentBallot.counter + 1) : 1;

        return bumpState(value, n);
    }

    // flavor that takes the actual desired counter value
    bool bumpState(ref Value value, uint32 n)
    {
        if (mPhase != BCPPhase.BCP_PHASE_PREPARE && mPhase != BCPPhase.BCP_PHASE_CONFIRM)
        {
            return false;
        }

        BCPBallot newb;

        newb.counter = n;

        if (mHighBallot)
        {
            // can only bump the counter if we committed to something already
            newb.value = mHighBallot.value;
        }
        else
        {
            newb.value = value;
        }

        //if (Logging::logDebug("BCP"))
        //writefln("[DEBUG], BCP BallotProtocol.bumpState i: %d v: %s", mSlot.getSlotIndex(), mSlot.getCP().ballotToStr(newb));

        bool updated = updateCurrentValue(newb);

        if (updated)
        {
            mSlot.getCPDriver().startedBallotProtocol(mSlot.getSlotIndex(), newb);
            emitCurrentStateStatement();
        }

        return updated;
    }

    // ** status methods

    // returns information about the local state in JSON format
    // including historical statements if available
    void dumpInfo(ref JSONValue ret)
    {
        import std.utf;

        JSONValue[string] stateObject;
        JSONValue state = stateObject;

        state.object["heard"] = JSONValue(mHeardFromQuorum);
        state.object["ballot"] = JSONValue(toUTF8(mSlot.getCP()
                .ballotToStr(cast(BCPBallot*) mCurrentBallot)));
        state.object["phase"] = JSONValue(toUTF8(mPhaseNames[mPhase]));
        state.object["state"] = JSONValue(toUTF8(getLocalState()));

        ret.object["ballotProtocol"] = state;
    }

    // returns information about the quorum for a given node
    void dumpQuorumInfo(ref JSONValue ret, ref NodeID id, bool summary)
    {
        import std.utf;

        // find the state of the node `id`
        BCPBallot* b;
        Hash qSetHash;

        auto pNode = (id in mLatestEnvelopes);
        if (pNode is null)
        {
            ret.object["phase"] = JSONValue("unknown");
            if (id == mSlot.getLocalNode().getNodeID())
            {
                qSetHash = mSlot.getLocalNode().getQuorumSetHash();
            }
        }
        else
        {
            auto st = &(mLatestEnvelopes[id].statement);

            switch (st.pledges.type)
            {
            case BCPStatementType.BCP_ST_PREPARE:
                ret.object["phase"] = JSONValue("PREPARE");
                b = &(*st).pledges.prepare.ballot;
                break;
            case BCPStatementType.BCP_ST_CONFIRM:
                ret.object["phase"] = JSONValue("CONFIRM");
                b = &(*st).pledges.confirm.ballot;
                break;
            case BCPStatementType.BCP_ST_EXTERNALIZE:
                ret.object["phase"] = JSONValue("EXTERNALIZE");
                b = &(*st).pledges.externalize.commit;
                break;
            default:
                dbgAbort();
            }
            // use the companion set here even for externalize to capture
            // the view of the quorum set during consensus
            qSetHash = mSlot.getCompanionQuorumSetHashFromStatement(*st);
        }

        int n_missing = 0, n_disagree = 0;

        int agree = 0;
        auto qSet = mSlot.getCPDriver().getQSet(qSetHash);
        if (!qSet.refCountedStore.isInitialized)
        {
            ret.object["phase"] = JSONValue("expired");
            return;
        }

        if (summary)
        {
            JSONValue[string] disagreeObject;
            JSONValue[string] missingObject;

            ret.object["disagree"] = disagreeObject;
            ret.object["missing"] = missingObject;
        }
        else
        {
            JSONValue[] disagreeArray;
            ret.object["disagree"] = disagreeArray;

            JSONValue[] missingArray;
            ret.object["missing"] = missingArray;
        }

        LocalNode.forAllNodes(qSet, (ref NodeID n) {
            auto pN = (n in mLatestEnvelopes);
            if (pN is null)
            {
                if (!summary)
                {
                    ret["missing"].array ~= JSONValue(mSlot.getCPDriver()
                        .toShortString(n));
                }
                n_missing++;
            }
            else if (areBallotsCompatible(getWorkingBallot(mLatestEnvelopes[n].statement), *b))
            {
                agree++;
            }
            else
            {
                if (!summary)
                {
                    ret["disagree"].array ~= JSONValue(mSlot.getCPDriver()
                        .toShortString(n));
                }
                n_disagree++;
            }
        });

        if (summary)
        {
            ret["missing"] = JSONValue(n_missing);
            ret["disagree"] = JSONValue(n_disagree);
        }

        NodeID[] f = LocalNode.findClosestVBlocking(qSet, mLatestEnvelopes, (ref BCPStatement st) {
            return areBallotsCompatible(getWorkingBallot(st), *b);
        }, &id);

        ret.object["fail_at"] = JSONValue(cast(int)(f.length));

        if (!summary)
        {
            JSONValue[] failWithArray;
            ret.object["fail_with"] = failWithArray;

            for (int i = 0; i < f.length; i++)
            {
                ret["fail_with"].array ~= JSONValue(toUTF8(mSlot.getCPDriver()
                        .toShortString(f[i])));
            }

            JSONValue[string] valueObject;
            JSONValue value = valueObject;

            getLocalNode().toJson(qSet, value);

            ret.object["value"] = value;
        }

        ret.object["hash"] = JSONValue(toHexString(qSetHash.hash));
        ret.object["agree"] = JSONValue(agree);
    }

    // returns the hash of the BCPQuorumSet that should be downloaded
    // with the statement.
    // note: the companion hash for an EXTERNALIZE statement does
    // not match the hash of the QSet, but the hash of commitQuorumSetHash
    static Hash getCompanionQuorumSetHashFromStatement(ref BCPStatement st)
    {
        Hash h;
        switch (st.pledges.type)
        {
        case BCPStatementType.BCP_ST_PREPARE:
            h = st.pledges.prepare.quorumSetHash;
            break;
        case BCPStatementType.BCP_ST_CONFIRM:
            h = st.pledges.confirm.quorumSetHash;
            break;
        case BCPStatementType.BCP_ST_EXTERNALIZE:
            h = st.pledges.externalize.commitQuorumSetHash;
            break;
        default:
            dbgAbort();
        }
        return h;
    }

    // helper function to retrieve b for PREPARE, P for CONFIRM or
    // c for EXTERNALIZE messages
    static BCPBallot getWorkingBallot(ref BCPStatement st)
    {
        BCPBallot res;
        switch (st.pledges.type)
        {
        case BCPStatementType.BCP_ST_PREPARE:
            res = st.pledges.prepare.ballot;
            break;
        case BCPStatementType.BCP_ST_CONFIRM:
            {
                auto con = &st.pledges.confirm;
                res.counter = con.nCommit;
                res.value = con.ballot.value;
            }
            break;
        case BCPStatementType.BCP_ST_EXTERNALIZE:
            res = st.pledges.externalize.commit;
            break;
        default:
            dbgAbort();
        }
        return res;
    }

    BCPEnvelopePtr getLastMessageSend()
    {
        return mLastEnvelopeEmit;
    }

    void setStateFromEnvelope(ref BCPEnvelope e)
    {
        if (mCurrentBallot)
        {
            throw new Exception("Cannot set state after starting ballot protocol");
        }

        recordEnvelope(e);

        mLastEnvelope = refCounted(e);
        mLastEnvelopeEmit = mLastEnvelope;

        BCPBallot ballot;
        auto pl = &e.statement.pledges;

        switch (pl.type)
        {
        case BCPStatementType.BCP_ST_PREPARE:
            {
                auto prep = &pl.prepare;
                auto b = &prep.ballot;

                bumpToBallot(*b, true);
                if (prep.prepared.counter > 0)
                {
                    mPrepared = cast(UniqueStruct!BCPBallot)(new BCPBallot(prep.prepared.counter,
                            prep.prepared.value));
                }
                if (prep.preparedPrime.counter > 0)
                {
                    mPreparedPrime = cast(UniqueStruct!BCPBallot)(new BCPBallot(prep.preparedPrime.counter,
                            prep.preparedPrime.value));
                }
                if (prep.nH > 0)
                {
                    mHighBallot = cast(UniqueStruct!BCPBallot)(new BCPBallot(prep.nH, b.value));
                }
                if (prep.nC > 0)
                {
                    mCommit = cast(UniqueStruct!BCPBallot)(new BCPBallot(prep.nC, b.value));
                }
                mPhase = BCPPhase.BCP_PHASE_PREPARE;
            }
            break;
        case BCPStatementType.BCP_ST_CONFIRM:
            {
                auto c = &pl.confirm;
                auto v = &c.ballot.value;

                bumpToBallot(c.ballot, true);

                mPrepared = cast(UniqueStruct!BCPBallot)(new BCPBallot(c.nPrepared, c.ballot.value));
                mHighBallot = cast(UniqueStruct!BCPBallot)(new BCPBallot(c.nH, c.ballot.value));
                mCommit = cast(UniqueStruct!BCPBallot)(new BCPBallot(c.nCommit, c.ballot.value));
                mPhase = BCPPhase.BCP_PHASE_CONFIRM;
            }
            break;
        case BCPStatementType.BCP_ST_EXTERNALIZE:
            {
                auto ext = &pl.externalize;
                auto v = &ext.commit.value;
                ballot = BCPBallot(UINT32_MAX, ext.commit.value);
                bumpToBallot(ballot, true);

                mPrepared = cast(UniqueStruct!BCPBallot)(new BCPBallot(UINT32_MAX, ext.commit.value));
                mHighBallot = cast(UniqueStruct!BCPBallot)(new BCPBallot(ext.nH, ext.commit.value));
                mCommit = cast(UniqueStruct!BCPBallot)(new BCPBallot(ext.commit.counter, ext.commit.value));
                mPhase = BCPPhase.BCP_PHASE_EXTERNALIZE;
            }
            break;
        default:
            dbgAbort();
        }
    }

    BCPEnvelope[] getCurrentState()
    {
        BCPEnvelope[] res;
        foreach (ref const NodeID n, ref BCPEnvelope e; mLatestEnvelopes)
        {
            // only return messages for self if the slot is fully validated
            if (!(n == mSlot.getCP().getLocalNodeID()) || mSlot.isFullyValidated())
            {
                res ~= e;
            }
        }
        return res;
    }

    BCPEnvelope[] getExternalizingState()
    {
        BCPEnvelope[] res;
        if (mPhase == BCPPhase.BCP_PHASE_EXTERNALIZE)
        {
            foreach (ref const NodeID n, ref BCPEnvelope e; mLatestEnvelopes)
            {
                if (!(n == mSlot.getCP().getLocalNodeID()))
                {
                    // good approximation: statements with the value that
                    // externalized
                    // we could filter more using mConfirmedPrepared as well
                    if (areBallotsCompatible(getWorkingBallot(e.statement), *mCommit))
                    {
                        res ~= e;
                    }
                }
                else if (mSlot.isFullyValidated())
                {
                    // only return messages for self if the slot is fully validated
                    res ~= e;
                }
            }
        }
        return res;
    }

private:
    // attempts to make progress using the latest statement as a hint
    // calls into the various attempt* methods, emits message
    // to make progress
    void advanceSlot(ref BCPStatement hint)
    {
        mCurrentMessageLevel++;

        //if (Logging::logDebug("BCP"))
        //writefln("[DEBUG], BCP BallotProtocol.advanceSlot %d %s ", mCurrentMessageLevel, getLocalState());

        if (mCurrentMessageLevel >= MAX_ADVANCESLOT_RECURSION)
        {
            throw new Exception("maximum number of transitions reached in advanceSlot");
        }

        // Check if we should call `ballotDidHearFromQuorum`
        // we do this here so that we have a chance to evaluate it between
        // transitions
        // when a single message causes several
        if (!mHeardFromQuorum && mCurrentBallot)
        {
            if (LocalNode.isQuorum(getLocalNode().getQuorumSet(),
                    mLatestEnvelopes, (ref BCPStatement st) {
                        return mSlot.getQuorumSetFromStatement(st);
                    }, (ref BCPStatement st) {
                        bool res;
                        if (st.pledges.type == BCPStatementType.BCP_ST_PREPARE)
                        {
                            res = mCurrentBallot.counter <= st.pledges.prepare.ballot.counter;
                        }
                        else
                        {
                            res = true;
                        }
                        return res;
                    }))
            {
                mHeardFromQuorum = true;
                mSlot.getCPDriver().ballotDidHearFromQuorum(mSlot.getSlotIndex(), *mCurrentBallot);
            }
        }

        // attempt* methods will queue up messages, causing advanceSlot to be
        // called recursively

        // done in order so that we follow the steps from the white paper in
        // order
        // allowing the state to be updated properly

        bool didWork = false;

        didWork = attemptPreparedAccept(hint) || didWork;
        didWork = attemptPreparedConfirmed(hint) || didWork;
        didWork = attemptAcceptCommit(hint) || didWork;
        didWork = attemptConfirmCommit(hint) || didWork;

        // only bump after we're done with everything else
        if (mCurrentMessageLevel == 1)
        {
            bool didBump = false;
            do
            {
                // attemptBump may invoke advanceSlot recursively
                didBump = attemptBump();
                didWork = didBump || didWork;
            }
            while (didBump);
        }

        //if (Logging::logDebug("BCP"))
        //writefln("[DEBUG], BCP BallotProtocol.advanceSlot %d - exiting %s ", mCurrentMessageLevel, getLocalState());

        --mCurrentMessageLevel;

        if (didWork)
        {
            sendLatestEnvelope();
        }
    }

    // returns true if all values in statement are valid
    BCPDriver.ValidationLevel validateValues(ref BCPStatement st)
    {
        ValueSet values = new ValueSet;
        switch (st.pledges.type)
        {
        case BCPStatementType.BCP_ST_PREPARE:
            {
                auto prep = &st.pledges.prepare;
                auto b = &prep.ballot;
                if (b.counter != 0)
                {
                    values.insert(prep.ballot.value);
                }
                if (prep.prepared.counter != 0)
                {
                    values.insert(prep.prepared.value);
                }
            }
            break;

        case BCPStatementType.BCP_ST_CONFIRM:
            values.insert(st.pledges.confirm.ballot.value);
            break;

        case BCPStatementType.BCP_ST_EXTERNALIZE:
            values.insert(st.pledges.externalize.commit.value);
            break;

        default:
            // This shouldn't happen
            return BCPDriver.ValidationLevel.kInvalidValue;
        }

        BCPDriver.ValidationLevel res
            = BCPDriver.ValidationLevel.kFullyValidatedValue;
        foreach (ref Value v; values)
        {
            auto level = mSlot.getCPDriver().validateValue(mSlot.getSlotIndex(), v);
            if (level != BCPDriver.ValidationLevel.kFullyValidatedValue)
            {
                if (level == BCPDriver.ValidationLevel.kInvalidValue)
                {
                    res = BCPDriver.ValidationLevel.kInvalidValue;
                }
                else
                {
                    res = BCPDriver.ValidationLevel.kMaybeValidValue;
                }
            }
        }
        return res;
    }

    // send latest envelope if needed
    void sendLatestEnvelope()
    {
        // emit current envelope if needed
        if (mCurrentMessageLevel == 0
                && mLastEnvelope.refCountedStore.isInitialized && mSlot.isFullyValidated())
        {
            if (!mLastEnvelopeEmit.refCountedStore.isInitialized
                    || mLastEnvelope != mLastEnvelopeEmit)
            {
                mLastEnvelopeEmit = mLastEnvelope;
                mSlot.getCPDriver().emitEnvelope(mLastEnvelopeEmit);
            }
        }
    }

    // `attempt*` methods are called by `advanceSlot` internally call the
    //  the `set*` methods.
    //   * check if the specified state for the current slot has been
    //     reached or not.
    //   * idempotent
    //  input: latest statement received (used as a hint to reduce the
    //  space to explore)
    //  output: returns true if the state was updated

    // `set*` methods progress the slot to the specified state
    //  input: state specific
    //  output: returns true if the state was updated.

    // step 1 and 5 from the CP paper
    bool attemptPreparedAccept(ref BCPStatement hint)
    {
        if (mPhase != BCPPhase.BCP_PHASE_PREPARE && mPhase != BCPPhase.BCP_PHASE_CONFIRM)
        {
            return false;
        }

        BCPBallotSet candidates = getPrepareCandidates(hint);

        // see if we can accept any of the candidates, starting with the highest
        foreach_reverse (ref BCPBallot ballot; candidates)
        {

            if (mPhase == BCPPhase.BCP_PHASE_CONFIRM)
            {
                // only consider the ballot if it may help us increase
                // p (note: at this point, p ~ c)
                if (!areBallotsLessAndCompatible(*mPrepared, ballot))
                {
                    continue;
                }
                dbgAssert(areBallotsCompatible(*mCommit, ballot));
            }

            // if we already prepared this ballot, don't bother checking again

            // if ballot <= p' ballot is neither a candidate for p nor p'
            if (mPreparedPrime && compareBallots(ballot, *mPreparedPrime) <= 0)
            {
                continue;
            }

            if (mPrepared)
            {
                // if ballot is already covered by p, skip
                if (areBallotsLessAndCompatible(ballot, *mPrepared))
                {
                    continue;
                }
                // otherwise, there is a chance it increases p'
            }

            bool accepted = federatedAccept(// checks if any node is voting for this ballot
                    (ref BCPStatement st) {
                bool res;

                switch (st.pledges.type)
                {
                case BCPStatementType.BCP_ST_PREPARE:
                    {
                        auto p = &st.pledges.prepare;
                        res = areBallotsLessAndCompatible(ballot, p.ballot);
                    }
                    break;
                case BCPStatementType.BCP_ST_CONFIRM:
                    {
                        auto c = &st.pledges.confirm;
                        res = areBallotsCompatible(ballot, c.ballot);
                    }
                    break;
                case BCPStatementType.BCP_ST_EXTERNALIZE:
                    {
                        auto e = &st.pledges.externalize;
                        res = areBallotsCompatible(ballot, e.commit);
                    }
                    break;
                default:
                    res = false;
                    dbgAbort();
                }

                return res;
            }, (ref BCPStatement st) {
                return BallotProtocol.hasPreparedBallot(ballot, st);
            });

            if (accepted)
            {
                return setPreparedAccept(ballot);
            }
        }

        return false;
    }

    // prepared: ballot that should be prepared
    bool setPreparedAccept(ref BCPBallot ballot)
    {
        //if (Logging::logDebug("BCP"))
        //writefln("[DEBUG], BCP BallotProtocol.setPreparedAccept i: %d  b : %s ", mSlot.getSlotIndex(), mSlot.getCP().ballotToStr(ballot));

        // update our state
        bool didWork = setPrepared(ballot);

        // check if we also need to clear 'c'
        if (mCommit && mHighBallot)
        {
            if ((mPrepared && areBallotsLessAndIncompatible(*mHighBallot, *mPrepared))
                    || (mPreparedPrime && areBallotsLessAndIncompatible(*mHighBallot,
                        *mPreparedPrime)))
            {
                dbgAssert(mPhase == BCPPhase.BCP_PHASE_PREPARE);
                mCommit.release();
                didWork = true;
            }
        }

        if (didWork)
        {
            mSlot.getCPDriver().acceptedBallotPrepared(mSlot.getSlotIndex(), ballot);
            emitCurrentStateStatement();
        }

        return didWork;
    }

    // step 2+3+8 from the BCP paper
    // ballot is the candidate to record as 'confirmed prepared'
    bool attemptPreparedConfirmed(ref BCPStatement hint)
    {
        if (mPhase != BCPPhase.BCP_PHASE_PREPARE)
        {
            return false;
        }

        // check if we could accept this ballot as prepared
        if (!mPrepared)
        {
            return false;
        }

        BCPBallotSet candidates1 = getPrepareCandidates(hint);
        BCPBallot[] candidates;
        foreach_reverse (ref BCPBallot ballot; candidates1)
        {
            candidates ~= ballot;
        }

        // see if we can accept any of the candidates, starting with the highest
        BCPBallot newH;
        bool newHfound = false;
        int idx;
        for (idx = 0; idx < candidates.length; idx++)
        {
            BCPBallot* ballot = &candidates[idx];
            // only consider it if we can potentially raise h
            if (mHighBallot && compareBallots(*mHighBallot, *ballot) >= 0)
            {
                break;
            }

            bool ratified = federatedRatify((ref BCPStatement st) {
                return BallotProtocol.hasPreparedBallot(*ballot, st);
            });

            if (ratified)
            {
                newH = *ballot;
                newHfound = true;
                break;
            }
        }

        bool res = false;

        if (newHfound)
        {
            BCPBallot newC;
            // now, look for newC (left as 0 if no update)
            // step (3) from the paper
            BCPBallot b = mCurrentBallot ? *mCurrentBallot : BCPBallot();
            if ((!mCommit) && (!mPrepared || !areBallotsLessAndIncompatible(newH, *mPrepared))
                    && (!mPreparedPrime || !areBallotsLessAndIncompatible(newH, *mPreparedPrime)))
            {
                // continue where we left off (cur is at newH at this point)
                for (; idx < candidates.length; idx++)
                {
                    BCPBallot* ballot = &candidates[idx];

                    if (compareBallots(*ballot, b) < 0)
                    {
                        break;
                    }
                    bool ratified = federatedRatify((ref BCPStatement st) {
                        return BallotProtocol.hasPreparedBallot(*ballot, st);
                    });
                    if (ratified)
                    {
                        newC = *ballot;
                    }
                    else
                    {
                        break;
                    }
                }
            }
            res = setPreparedConfirmed(newC, newH);
        }
        return res;
    }

    // newC, newH : low/high bounds prepared confirmed
    bool setPreparedConfirmed(ref BCPBallot newC, ref BCPBallot newH)
    {
        //if (Logging::logDebug("BCP"))
        //writefln("[DEBUG], BCP BallotProtocol.setPreparedConfirmed i: %d  h : %s ", mSlot.getSlotIndex(), mSlot.getCP().ballotToStr(newH));

        bool didWork = false;

        if (!mHighBallot || compareBallots(newH, *mHighBallot) > 0)
        {
            didWork = true;
            mHighBallot = cast(UniqueStruct!BCPBallot)(new BCPBallot(newH.counter, newH.value));
        }

        if (newC.counter != 0)
        {
            dbgAssert(!mCommit);
            mCommit = cast(UniqueStruct!BCPBallot)(new BCPBallot(newC.counter, newC.value));
            didWork = true;
        }

        if (didWork)
        {
            updateCurrentIfNeeded();

            mSlot.getCPDriver().confirmedBallotPrepared(mSlot.getSlotIndex(), newH);
            emitCurrentStateStatement();
        }
        return didWork;
    }

    // step (4 and 6)+8 from the BCP paper
    bool attemptAcceptCommit(ref BCPStatement hint)
    {
        if (mPhase != BCPPhase.BCP_PHASE_PREPARE && mPhase != BCPPhase.BCP_PHASE_CONFIRM)
        {
            return false;
        }

        // extracts value from hint
        // note: ballot.counter is only used for logging purpose as we're looking at
        // possible value to commit
        BCPBallot ballot;
        switch (hint.pledges.type)
        {
        case BCPStatementType.BCP_ST_PREPARE:
            {
                auto prep = &hint.pledges.prepare;
                if (prep.nC != 0)
                {
                    ballot = BCPBallot(prep.nH, prep.ballot.value);
                }
                else
                {
                    return false;
                }
            }
            break;
        case BCPStatementType.BCP_ST_CONFIRM:
            {
                auto con = &hint.pledges.confirm;
                ballot = BCPBallot(con.nH, con.ballot.value);
            }
            break;
        case BCPStatementType.BCP_ST_EXTERNALIZE:
            {
                auto ext = &hint.pledges.externalize;
                ballot = BCPBallot(ext.nH, ext.commit.value);
                break;
            }
        default:
            dbgAbort();
        }

        if (mPhase == BCPPhase.BCP_PHASE_CONFIRM)
        {
            if (!areBallotsCompatible(ballot, *mHighBallot))
            {
                return false;
            }
        }

        IntervalPredicate pred = (ref Interval cur) {
            return federatedAccept((ref BCPStatement st) {
                bool res = false;
                auto pl = &st.pledges;
                switch (pl.type)
                {
                case BCPStatementType.BCP_ST_PREPARE:
                    {
                        auto p = &pl.prepare;
                        if (areBallotsCompatible(ballot, p.ballot))
                        {
                            if (p.nC != 0)
                            {
                                res = p.nC <= cur.low && cur.high <= p.nH;
                            }
                        }
                    }
                    break;
                case BCPStatementType.BCP_ST_CONFIRM:
                    {
                        auto c = &pl.confirm;
                        if (areBallotsCompatible(ballot, c.ballot))
                        {
                            res = c.nCommit <= cur.low;
                        }
                    }
                    break;
                case BCPStatementType.BCP_ST_EXTERNALIZE:
                    {
                        auto e = &pl.externalize;
                        if (areBallotsCompatible(ballot, e.commit))
                        {
                            res = e.commit.counter <= cur.low;
                        }
                    }
                    break;
                default:
                    dbgAbort();
                }
                return res;
            }, (ref BCPStatement st) {
                return BallotProtocol.commitPredicate(ballot, cur, st);
            });
        };

        // build the boundaries to scan
        UInt32Set boundaries = getCommitBoundariesFromStatements(ballot);

        if (boundaries.empty)
        {
            return false;
        }

        // now, look for the high interval
        Interval candidate;

        findExtendedInterval(candidate, boundaries, pred);

        bool res = false;

        if (candidate.low != 0)
        {
            if (mPhase != BCPPhase.BCP_PHASE_CONFIRM || candidate.high > mHighBallot.counter)
            {
                BCPBallot c = BCPBallot(candidate.low, ballot.value);
                BCPBallot h = BCPBallot(candidate.high, ballot.value);
                res = setAcceptCommit(c, h);
            }
        }
        return res;
    }

    // new values for c and h
    bool setAcceptCommit(ref BCPBallot c, ref BCPBallot h)
    {
        //if (Logging::logDebug("BCP"))
        //writefln("[DEBUG], BCP BallotProtocol.setAcceptCommit i: %d  new c: %s new h: %s",
        //         mSlot.getSlotIndex(), mSlot.getCP().ballotToStr(c), mSlot.getCP().ballotToStr(h));

        bool didWork = false;

        if (!mHighBallot || !mCommit || compareBallots(*mHighBallot, h) != 0
                || compareBallots(*mCommit, c) != 0)
        {
            mCommit = cast(UniqueStruct!BCPBallot)(new BCPBallot(c.counter, c.value));
            mHighBallot = cast(UniqueStruct!BCPBallot)(new BCPBallot(h.counter, h.value));

            didWork = true;
        }

        if (mPhase == BCPPhase.BCP_PHASE_PREPARE)
        {
            mPhase = BCPPhase.BCP_PHASE_CONFIRM;
            if (mCurrentBallot && !areBallotsLessAndCompatible(h, *mCurrentBallot))
            {
                bumpToBallot(h, false);
            }
            mPreparedPrime.release();

            didWork = true;
        }

        if (didWork)
        {
            updateCurrentIfNeeded();

            mSlot.getCPDriver().acceptedCommit(mSlot.getSlotIndex(), h);
            emitCurrentStateStatement();
        }
        return didWork;
    }

    // step 7+8 from the BCP paper
    bool attemptConfirmCommit(ref BCPStatement hint)
    {
        if (mPhase != BCPPhase.BCP_PHASE_CONFIRM)
        {
            return false;
        }

        if (!mHighBallot || !mCommit)
        {
            return false;
        }

        // extracts value from hint
        // note: ballot.counter is only used for logging purpose
        BCPBallot ballot;
        switch (hint.pledges.type)
        {
        case BCPStatementType.BCP_ST_PREPARE:
            {
                return false;
            }
            //break;
        case BCPStatementType.BCP_ST_CONFIRM:
            {
                auto con = &hint.pledges.confirm;
                ballot = BCPBallot(con.nH, con.ballot.value);
            }
            break;
        case BCPStatementType.BCP_ST_EXTERNALIZE:
            {
                auto ext = &hint.pledges.externalize;
                ballot = BCPBallot(ext.nH, ext.commit.value);
                break;
            }
        default:
            dbgAbort();
        }

        if (!areBallotsCompatible(ballot, *mCommit))
        {
            return false;
        }

        UInt32Set boundaries = getCommitBoundariesFromStatements(ballot);
        Interval candidate;

        IntervalPredicate pred = (ref Interval cur) {
            return federatedRatify((ref BCPStatement st) {
                return BallotProtocol.commitPredicate(ballot, cur, st);
            });
        };

        findExtendedInterval(candidate, boundaries, pred);

        bool res = candidate.low != 0;
        if (res)
        {
            BCPBallot c = BCPBallot(candidate.low, ballot.value);
            BCPBallot h = BCPBallot(candidate.high, ballot.value);
            return setConfirmCommit(c, h);
        }
        return res;
    }

    bool setConfirmCommit(ref BCPBallot acceptCommitLow, ref BCPBallot acceptCommitHigh)
    {
        //if (Logging::logDebug("BCP"))
        //writefln("[DEBUG], BCP BallotProtocol.setConfirmCommit i: %d  new c: %s new h: %s",
        //         mSlot.getSlotIndex(), mSlot.getCP().ballotToStr(acceptCommitLow), mSlot.getCP().ballotToStr(acceptCommitHigh));

        mCommit = cast(UniqueStruct!BCPBallot)(new BCPBallot(acceptCommitLow.counter,
                acceptCommitLow.value));
        mHighBallot = cast(UniqueStruct!BCPBallot)(new BCPBallot(acceptCommitHigh.counter,
                acceptCommitHigh.value));
        updateCurrentIfNeeded();

        mPhase = BCPPhase.BCP_PHASE_EXTERNALIZE;

        emitCurrentStateStatement();

        mSlot.stopNomination();

        mSlot.getCPDriver().valueExternalized(mSlot.getSlotIndex(), mCommit.value);

        return true;
    }

    // step 9 from the BCP paper
    bool attemptBump()
    {
        if (mPhase == BCPPhase.BCP_PHASE_PREPARE || mPhase == BCPPhase.BCP_PHASE_CONFIRM)
        {
            // find all counters
            UInt32Set allCounters = new UInt32Set;
            foreach (ref const NodeID n, ref BCPEnvelope e; mLatestEnvelopes)
            {
                auto st = &e.statement;
                switch (st.pledges.type)
                {
                case BCPStatementType.BCP_ST_PREPARE:
                    {
                        auto p = &st.pledges.prepare;
                        allCounters.insert(p.ballot.counter);
                    }
                    break;
                case BCPStatementType.BCP_ST_CONFIRM:
                    {
                        auto c = &st.pledges.confirm;
                        allCounters.insert(c.ballot.counter);
                    }
                    break;
                case BCPStatementType.BCP_ST_EXTERNALIZE:
                    {
                        allCounters.insert(UINT32_MAX);
                    }
                    break;
                default:
                    dbgAbort();
                }
            }
            uint32 targetCounter = mCurrentBallot ? mCurrentBallot.counter : 0;

            // uses 0 as a way to track if a v-blocking set is at a higher counter
            // if so, we move to that smallest counter
            allCounters.insert(targetCounter);

            // go through the counters, find the smallest not v-blocking
            foreach (uint32 n; allCounters)
            {
                if (n < targetCounter)
                {
                    break;
                }

                bool vBlocking = LocalNode.isVBlocking(getLocalNode()
                        .getQuorumSet(), mLatestEnvelopes, (ref BCPStatement st) {
                            bool res;
                            auto pl = &st.pledges;
                            if (pl.type == BCPStatementType.BCP_ST_PREPARE)
                            {
                                res = n < pl.prepare.ballot.counter;
                            }
                            else
                            {
                                if (pl.type == BCPStatementType.BCP_ST_CONFIRM)
                                {
                                    res = n < pl.confirm.ballot.counter;
                                }
                                else
                                {
                                    res = n != UINT32_MAX;
                                }
                            }
                            return res;
                        });

                if (n == targetCounter)
                {
                    // if current counter is not behind, don't do anything
                    if (!vBlocking)
                    {
                        break;
                    }
                }
                else
                {
                    if (!vBlocking)
                    {
                        // move to n
                        return abandonBallot(n);
                    }
                }
            }
        }
        return false;
    }

    // computes a list of candidate values that may have been prepared
    BCPBallotSet getPrepareCandidates(ref BCPStatement hint)
    {
        BCPBallotSet hintBallots_ = new BCPBallotSet;

        switch (hint.pledges.type)
        {
        case BCPStatementType.BCP_ST_PREPARE:
            {
                auto prep = &hint.pledges.prepare;
                hintBallots_.insert(prep.ballot);
                if (prep.prepared.counter > 0)
                {
                    hintBallots_.insert(prep.prepared);
                }
                if (prep.preparedPrime.counter > 0)
                {
                    hintBallots_.insert(prep.preparedPrime);
                }
            }
            break;
        case BCPStatementType.BCP_ST_CONFIRM:
            {
                auto con = &hint.pledges.confirm;
                hintBallots_.insert(BCPBallot(con.nPrepared, con.ballot.value));
                hintBallots_.insert(BCPBallot(UINT32_MAX, con.ballot.value));
            }
            break;
        case BCPStatementType.BCP_ST_EXTERNALIZE:
            {
                auto ext = &hint.pledges.externalize;
                hintBallots_.insert(BCPBallot(UINT32_MAX, ext.commit.value));
            }
            break;
        default:
            dbgAbort();
        }

        BCPBallot[] hintBallots;
        foreach (ref BCPBallot ballot; hintBallots_)
        {
            hintBallots ~= ballot;
        }

        BCPBallotSet candidates = new BCPBallotSet;

        while (hintBallots.length != 0)
        {
            BCPBallot topVote = hintBallots[$ - 1];
            hintBallots = hintBallots[0 .. $ - 1];

            auto val = &topVote.value;

            // find candidates that may have been prepared
            foreach (NodeID n, ref BCPEnvelope e; mLatestEnvelopes)
            {
                auto st = &e.statement;
                switch (st.pledges.type)
                {
                case BCPStatementType.BCP_ST_PREPARE:
                    {
                        auto prep = &st.pledges.prepare;
                        if (areBallotsLessAndCompatible(prep.ballot, topVote))
                        {
                            candidates.insert(prep.ballot);
                        }
                        if (prep.prepared.counter > 0
                                && areBallotsLessAndCompatible(prep.prepared, topVote))
                        {
                            candidates.insert(prep.prepared);
                        }
                        if (prep.preparedPrime.counter > 0
                                && areBallotsLessAndCompatible(prep.preparedPrime, topVote))
                        {
                            candidates.insert(prep.preparedPrime);
                        }
                    }
                    break;
                case BCPStatementType.BCP_ST_CONFIRM:
                    {
                        auto con = &st.pledges.confirm;
                        if (areBallotsCompatible(topVote, con.ballot))
                        {
                            candidates.insert(topVote);
                            if (con.nPrepared < topVote.counter)
                            {
                                candidates.insert(BCPBallot(con.nPrepared, *val));
                            }
                        }
                    }
                    break;
                case BCPStatementType.BCP_ST_EXTERNALIZE:
                    {
                        auto ext = &st.pledges.externalize;
                        if (areBallotsCompatible(topVote, ext.commit))
                        {
                            candidates.insert(topVote);
                        }
                    }
                    break;
                default:
                    dbgAbort();
                }
            }
        }

        return candidates;
    }

    // helper to perform step (8) from the paper
    void updateCurrentIfNeeded()
    {
        if (!mCurrentBallot || compareBallots(*mCurrentBallot, *mHighBallot) < 0)
        {
            bumpToBallot(*mHighBallot, true);
        }
    }

    // helper function to find a contiguous range 'candidate' that satisfies the
    // predicate.
    // updates 'candidate' (or leave it unchanged)
    static void findExtendedInterval(ref Interval candidate,
            ref const UInt32Set boundaries, IntervalPredicate pred)
    {
        // iterate through interesting boundaries, starting from the top
        foreach_reverse (uint32 b; boundaries)
        {
            Interval cur;
            if (candidate.low == 0)
            {
                // first, find the high bound
                cur = Interval(b, b);
            }
            else if (b > candidate.high) // invalid
            {
                continue;
            }
            else
            {
                cur.low = b;
                cur.high = candidate.high;
            }

            if (pred(cur))
            {
                candidate = cur;
            }
            else if (candidate.low != 0)
            {
                // could not extend further
                break;
            }
        }
    }

    // constructs the set of counters representing the
    // commit ballots compatible with the ballot
    UInt32Set getCommitBoundariesFromStatements(ref BCPBallot ballot)
    {
        UInt32Set res = new UInt32Set;
        foreach (ref const NodeID n, ref BCPEnvelope env; mLatestEnvelopes)
        {
            auto pl = &env.statement.pledges;
            switch (pl.type)
            {
            case BCPStatementType.BCP_ST_PREPARE:
                {
                    auto p = &pl.prepare;
                    if (areBallotsCompatible(ballot, p.ballot))
                    {
                        if (p.nC)
                        {
                            res.insert(p.nC);
                            res.insert(p.nH);
                        }
                    }
                }
                break;
            case BCPStatementType.BCP_ST_CONFIRM:
                {
                    auto c = &pl.confirm;
                    if (areBallotsCompatible(ballot, c.ballot))
                    {
                        res.insert(c.nCommit);
                        res.insert(c.nH);
                    }
                }
                break;
            case BCPStatementType.BCP_ST_EXTERNALIZE:
                {
                    auto e = &pl.externalize;
                    if (areBallotsCompatible(ballot, e.commit))
                    {
                        res.insert(e.commit.counter);
                        res.insert(e.nH);
                        res.insert(UINT32_MAX);
                    }
                }
                break;

            default:
                //dbgAbort();
            }
        }
        return res;
    }

    // ** helper predicates that evaluate if a statement satisfies
    // a certain property

    // is ballot prepared by st
    static bool hasPreparedBallot(ref BCPBallot ballot, ref BCPStatement st)
    {
        bool res;

        switch (st.pledges.type)
        {
        case BCPStatementType.BCP_ST_PREPARE:
            {
                auto p = &st.pledges.prepare;
                res = (p.prepared.counter > 0 && areBallotsLessAndCompatible(ballot, p.prepared))
                    || (p.preparedPrime.counter > 0
                            && areBallotsLessAndCompatible(ballot, p.preparedPrime));
            }
            break;
        case BCPStatementType.BCP_ST_CONFIRM:
            {
                auto c = &st.pledges.confirm;
                BCPBallot prepared = BCPBallot(c.nPrepared, c.ballot.value);
                res = areBallotsLessAndCompatible(ballot, prepared);
            }
            break;
        case BCPStatementType.BCP_ST_EXTERNALIZE:
            {
                auto e = &st.pledges.externalize;
                res = areBallotsCompatible(ballot, e.commit);
            }
            break;
        default:
            res = false;
            dbgAbort();
        }

        return res;
    }

    // returns true if the statement commits the ballot in the range 'check'
    static bool commitPredicate(ref BCPBallot ballot, ref Interval check, ref BCPStatement st)
    {
        bool res = false;
        auto pl = &st.pledges;
        switch (pl.type)
        {
        case BCPStatementType.BCP_ST_PREPARE:
            break;
        case BCPStatementType.BCP_ST_CONFIRM:
            {
                auto c = &pl.confirm;
                if (areBallotsCompatible(ballot, c.ballot))
                {
                    res = c.nCommit <= check.low && check.high <= c.nH;
                }
            }
            break;
        case BCPStatementType.BCP_ST_EXTERNALIZE:
            {
                auto e = &pl.externalize;
                if (areBallotsCompatible(ballot, e.commit))
                {
                    res = e.commit.counter <= check.low;
                }
            }
            break;
        default:
            dbgAbort();
        }
        return res;
    }

    // attempts to update p to ballot (updating p' if needed)
    bool setPrepared(ref BCPBallot ballot)
    {
        bool didWork = false;

        if (mPrepared)
        {
            int comp = compareBallots(*mPrepared, ballot);
            if (comp < 0)
            {
                if (!areBallotsCompatible(*mPrepared, ballot))
                {
                    mPreparedPrime = cast(UniqueStruct!BCPBallot)(new BCPBallot(mPrepared.counter,
                            mPrepared.value));
                }
                mPrepared = cast(UniqueStruct!BCPBallot)(new BCPBallot(ballot.counter, ballot.value));
                didWork = true;
            }
            else if (comp > 0)
            {
                // check if we should update only p'
                if (!mPreparedPrime || compareBallots(*mPreparedPrime, ballot) < 0)
                {
                    mPreparedPrime = cast(UniqueStruct!BCPBallot)(new BCPBallot(ballot.counter,
                            ballot.value));
                    didWork = true;
                }
            }
        }
        else
        {
            mPrepared = cast(UniqueStruct!BCPBallot)(new BCPBallot(ballot.counter, ballot.value));
            didWork = true;
        }
        return didWork;
    }
    // ** Helper methods to compare two ballots

    // ballot comparison (ordering)
    static int compareBallots(ref UniqueStruct!BCPBallot b1, ref UniqueStruct!BCPBallot b2)
    {
        int res;
        if (b1 && b2)
        {
            res = compareBallots(*b1, *b2);
        }
        else if (b1 && !b2)
        {
            res = 1;
        }
        else if (!b1 && b2)
        {
            res = -1;
        }
        else
        {
            res = 0;
        }
        return res;
    }

    static int compareBallots(ref BCPBallot b1, ref BCPBallot b2)
    {
        if (b1.counter < b2.counter)
        {
            return -1;
        }
        else if (b2.counter < b1.counter)
        {
            return 1;
        }
        // ballots are also strictly ordered by value
        if (b1.value.value < b2.value.value)
        {
            return -1;
        }
        else if (b2.value.value < b1.value.value)
        {
            return 1;
        }
        else
        {
            return 0;
        }
    }

    // b1 ~ b2
    static bool areBallotsCompatible(BCPBallot b1, BCPBallot b2)
    {
        return b1.value == b2.value;
    }

    // b1 <= b2 && b1 !~ b2
    static bool areBallotsLessAndIncompatible(ref BCPBallot b1, ref BCPBallot b2)
    {
        return (compareBallots(b1, b2) <= 0) && !(b1.value == b2.value);
    }

    // b1 <= b2 && b1 ~ b2
    static bool areBallotsLessAndCompatible(ref BCPBallot b1, ref BCPBallot b2)
    {
        return (compareBallots(b1, b2) <= 0) && (b1.value == b2.value);
    }

    // ** statement helper functions

    // returns true if the statement is newer than the one we know about
    // for a given node.
    bool isNewerStatement(ref NodeID nodeID, ref BCPStatement st)
    {
        bool res = false;
        auto pN = (nodeID in mLatestEnvelopes);
        if (pN is null)
        {
            res = true;
        }
        else
        {
            res = isNewerStatement(mLatestEnvelopes[nodeID].statement, st);
        }
        return res;
    }

    // returns true if st is newer than oldst
    static bool isNewerStatement(ref BCPStatement oldst, ref BCPStatement st)
    {
        bool res = false;

        // total ordering described in BCP paper.
        auto t = st.pledges.type;

        // statement type (PREPARE < CONFIRM < EXTERNALIZE)
        if (oldst.pledges.type != t)
        {
            res = (oldst.pledges.type < t);
        }
        else
        {
            // can't have duplicate EXTERNALIZE statements
            if (t == BCPStatementType.BCP_ST_EXTERNALIZE)
            {
                res = false;
            }
            else if (t == BCPStatementType.BCP_ST_CONFIRM)
            {
                // sorted by (b, p, p', h) (p' = 0 implicitely)
                auto oldC = &oldst.pledges.confirm;
                auto c = &st.pledges.confirm;
                int compBallot = compareBallots(oldC.ballot, c.ballot);
                if (compBallot < 0)
                {
                    res = true;
                }
                else if (compBallot == 0)
                {
                    if (oldC.nPrepared == c.nPrepared)
                    {
                        res = (oldC.nH < c.nH);
                    }
                    else
                    {
                        res = (oldC.nPrepared < c.nPrepared);
                    }
                }
            }
            else
            {
                // Lexicographical order between PREPARE statements:
                // (b, p, p', h)
                auto oldPrep = &oldst.pledges.prepare;
                auto prep = &st.pledges.prepare;

                int compBallot = compareBallots(oldPrep.ballot, prep.ballot);
                if (compBallot < 0)
                {
                    res = true;
                }
                else if (compBallot == 0)
                {
                    compBallot = compareBallots(oldPrep.prepared, prep.prepared);
                    if (compBallot < 0)
                    {
                        res = true;
                    }
                    else if (compBallot == 0)
                    {
                        compBallot = compareBallots(oldPrep.preparedPrime, prep.preparedPrime);
                        if (compBallot < 0)
                        {
                            res = true;
                        }
                        else if (compBallot == 0)
                        {
                            res = (oldPrep.nH < prep.nH);
                        }
                    }
                }
            }
        }

        return res;
    }

    // basic sanity check on statement
    static bool isStatementSane(ref BCPStatement st, bool self)
    {
        auto res = true;

        switch (st.pledges.type)
        {
        case BCPStatementType.BCP_ST_PREPARE:
            {
                auto p = &st.pledges.prepare;
                // self is allowed to have b = 0 (as long as it never gets emitted)
                bool isOK = self || p.ballot.counter > 0;

                isOK = isOK && ((!p.preparedPrime.counter || !p.prepared.counter)
                        || (areBallotsLessAndIncompatible(p.preparedPrime, p.prepared)));

                isOK = isOK && (p.nH == 0 || (p.prepared.counter && p.nH <= p.prepared.counter));

                // c != 0 -> c <= h <= b
                isOK = isOK && (p.nC == 0 || (p.nH != 0 && p.ballot.counter >= p.nH && p.nH >= p.nC));

                if (!isOK)
                {
                    writefln("[DEBUG], BCP Malformed PREPARE message");
                    res = false;
                }
            }
            break;

        case BCPStatementType.BCP_ST_CONFIRM:
            {
                auto c = &st.pledges.confirm;
                // c <= h <= b
                res = c.ballot.counter > 0;
                res = res && (c.nH <= c.ballot.counter);
                res = res && (c.nCommit <= c.nH);
                if (!res)
                {
                    writefln("[DEBUG], BCP Malformed CONFIRM message");
                }
            }
            break;

        case BCPStatementType.BCP_ST_EXTERNALIZE:
            {
                auto e = &st.pledges.externalize;

                res = e.commit.counter > 0;
                res = res && e.nH >= e.commit.counter;

                if (!res)
                {
                    writefln("[DEBUG], BCP Malformed EXTERNALIZE message");
                }
            }
            break;

        default:
            dbgAbort();
        }

        return res;
    }

    // records the statement in the state machine
    void recordEnvelope(ref BCPEnvelope env)
    {
        auto st = &env.statement;

        auto p = (st.nodeID in mLatestEnvelopes);
        if (p is null)
        {
            mLatestEnvelopes[st.nodeID] = env;
        }
        else
        {
            *p = env;
        }
        mSlot.recordStatement(env.statement);
    }

    // ** State related methods
    // helper function that updates the current ballot
    // this is the lowest level method to update the current ballot and as
    // such doesn't do any validation
    // check: verifies that ballot is greater than old one
    void bumpToBallot(ref BCPBallot ballot, bool check)
    {
        //if (Logging::logDebug("BCP"))
        //writefln("[DEBUG], BCP BallotProtocol.bumpToBallot i: %d b: %s", mSlot.getSlotIndex(), mSlot.getCP().ballotToStr(ballot));

        // `bumpToBallot` should be never called once we committed.
        dbgAssert(mPhase != BCPPhase.BCP_PHASE_EXTERNALIZE);

        if (check)
        {
            // We should move mCurrentBallot monotonically only
            dbgAssert(!mCurrentBallot || compareBallots(ballot, *mCurrentBallot) >= 0);
        }

        bool gotBumped = !mCurrentBallot || !(*mCurrentBallot == ballot);

        mCurrentBallot = cast(UniqueStruct!BCPBallot)(new BCPBallot(ballot.counter, ballot.value));

        mHeardFromQuorum = false;

        if (gotBumped)
            startBallotProtocolTimer();
    }

    // switch the local node to the given ballot's value
    // with the assumption that the ballot is more recent than the one
    // we have.
    bool updateCurrentValue(ref BCPBallot ballot)
    {
        if (mPhase != BCPPhase.BCP_PHASE_PREPARE && mPhase != BCPPhase.BCP_PHASE_CONFIRM)
        {
            return false;
        }

        bool updated = false;
        if (!mCurrentBallot)
        {
            bumpToBallot(ballot, true);
            updated = true;
        }
        else
        {
            dbgAssert(compareBallots(*mCurrentBallot, ballot) <= 0);

            if (mCommit && !areBallotsCompatible(*mCommit, ballot))
            {
                return false;
            }

            int comp = compareBallots(*mCurrentBallot, ballot);
            if (comp < 0)
            {
                bumpToBallot(ballot, true);
                updated = true;
            }
            else if (comp > 0)
            {
                // this code probably changes with the final version
                // of the conciliator

                // this case may happen if the other nodes are not
                // following the protocol (and we end up with a smaller value)
                // not sure what is the best way to deal
                // with this situation
                writefln(
                        "[ERROR], BCP BallotProtocol.updateCurrentValue attempt to bump to a smaller value");
                // can't just bump to the value as we may already have
                // statements at counter+1
                return false;
            }
        }

        if (updated)
        {
            //writefln("[TRACE], BCP BallotProtocol.updateCurrentValue updated");
        }

        checkInvariants();

        return updated;
    }

    // emits a statement reflecting the nodes' current state
    // and attempts to make progress
    void emitCurrentStateStatement()
    {
        BCPStatementType t;

        switch (mPhase)
        {
        case BCPPhase.BCP_PHASE_PREPARE:
            t = BCPStatementType.BCP_ST_PREPARE;
            break;
        case BCPPhase.BCP_PHASE_CONFIRM:
            t = BCPStatementType.BCP_ST_CONFIRM;
            break;
        case BCPPhase.BCP_PHASE_EXTERNALIZE:
            t = BCPStatementType.BCP_ST_EXTERNALIZE;
            break;
        default:
            dbgAbort();
        }

        BCPStatement statement = createStatement(t);
        BCPEnvelope envelope = mSlot.createEnvelope(statement);

        bool canEmit = (mCurrentBallot != null);

        // if we generate the same envelope, don't process it again
        // this can occur when updating h in PREPARE phase
        // as statements only keep track of h.n (but h.x could be different)
        NodeID nID = mSlot.getCP().getLocalNodeID();
        auto pN = (nID in mLatestEnvelopes);

        if ((pN is null) || !(mLatestEnvelopes[nID] == envelope))
        {
            if (mSlot.processEnvelope(envelope, true) == BCP.EnvelopeState.VALID)
            {
                if (canEmit && (!mLastEnvelope.refCountedStore.isInitialized
                        || isNewerStatement(mLastEnvelope.statement, envelope.statement)))
                {
                    mLastEnvelope = refCounted(envelope);
                    // this will no-op if invoked from advanceSlot
                    // as advanceSlot consolidates all messages sent
                    sendLatestEnvelope();
                }
            }
            else
            {
                // there is a bug in the application if it queued up
                // a statement for itself that it considers invalid
                throw new Exception("moved to a bad state (ballot protocol)");
            }
        }
    }

    // verifies that the internal state is consistent
    void checkInvariants()
    {
        if (mCurrentBallot)
        {
            dbgAssert(mCurrentBallot.counter != 0);
        }

        if (mPrepared && mPreparedPrime)
        {
            dbgAssert(areBallotsLessAndIncompatible(*mPreparedPrime, *mPrepared));
        }

        if (mCommit)
        {
            dbgAssert(mCurrentBallot != null);
            dbgAssert(areBallotsLessAndCompatible(*mCommit, *mHighBallot));
            dbgAssert(areBallotsLessAndCompatible(*mHighBallot, *mCurrentBallot));
        }

        switch (mPhase)
        {
        case BCPPhase.BCP_PHASE_PREPARE:
            break;
        case BCPPhase.BCP_PHASE_CONFIRM:
            dbgAssert(mCommit != null);
            break;
        case BCPPhase.BCP_PHASE_EXTERNALIZE:
            dbgAssert(mCommit != null);
            dbgAssert(mHighBallot != null);
            break;
        default:
            dbgAbort();
        }
    }

    // create a statement of the given type using the local state
    BCPStatement createStatement(ref BCPStatementType type)
    {
        BCPStatement statement;

        checkInvariants();

        statement.pledges.type = type;
        switch (type)
        {
        case BCPStatementType.BCP_ST_PREPARE:
            {
                statement.pledges.prepare.quorumSetHash = getLocalNode().getQuorumSetHash();
                if (mCurrentBallot)
                {
                    statement.pledges.prepare.ballot = *mCurrentBallot;
                }
                if (mCommit)
                {
                    statement.pledges.prepare.nC = mCommit.counter;
                }
                if (mPrepared)
                {
                    statement.pledges.prepare.prepared = *mPrepared;
                }
                if (mPreparedPrime)
                {
                    statement.pledges.prepare.preparedPrime = *mPreparedPrime;
                }
                if (mHighBallot)
                {
                    statement.pledges.prepare.nH = mHighBallot.counter;
                }
            }
            break;
        case BCPStatementType.BCP_ST_CONFIRM:
            {
                auto c = &statement.pledges.confirm;
                c.quorumSetHash = getLocalNode().getQuorumSetHash();
                dbgAssert(areBallotsLessAndCompatible(*mCommit, *mHighBallot));
                c.ballot = *mCurrentBallot;
                c.nPrepared = mPrepared.counter;
                c.nCommit = mCommit.counter;
                c.nH = mHighBallot.counter;
            }
            break;
        case BCPStatementType.BCP_ST_EXTERNALIZE:
            {
                dbgAssert(areBallotsLessAndCompatible(*mCommit, *mHighBallot));
                auto e = &statement.pledges.externalize;
                e.commit = *mCommit;
                e.nH = mHighBallot.counter;
                e.commitQuorumSetHash = getLocalNode().getQuorumSetHash();
            }
            break;
        default:
            dbgAbort();
        }

        return statement;
    }

    // returns a string representing the slot's state
    // used for log lines
    string getLocalState()
    {
        import std.outbuffer;

        OutBuffer oBuffer = new OutBuffer();
        oBuffer.writef("i: %d | %s", mSlot.getSlotIndex(), mPhaseNames[mPhase]);
        oBuffer.writef(" | b: %s", mSlot.getCP().ballotToStr(cast(BCPBallot*) mCurrentBallot));
        oBuffer.writef(" | p: %s", mSlot.getCP().ballotToStr(cast(BCPBallot*) mPrepared));
        oBuffer.writef(" | p: %s", mSlot.getCP().ballotToStr(cast(BCPBallot*) mPreparedPrime));
        oBuffer.writef(" | h: %s", mSlot.getCP().ballotToStr(cast(BCPBallot*) mHighBallot));
        oBuffer.writef(" | c: %s", mSlot.getCP().ballotToStr(cast(BCPBallot*) mCommit));
        oBuffer.writef(" | M: %d", mLatestEnvelopes.length);
        return oBuffer.toString();
    }

    LocalNode getLocalNode()
    {
        return mSlot.getCP().getLocalNode();
    }

    bool federatedAccept(StatementPredicate voted, StatementPredicate accepted)
    {
        return mSlot.federatedAccept(voted, accepted, mLatestEnvelopes);
    }

    bool federatedRatify(StatementPredicate voted)
    {
        return mSlot.federatedRatify(voted, mLatestEnvelopes);
    }

    void startBallotProtocolTimer()
    {
        Duration timeout = mSlot.getCPDriver().computeTimeout(mCurrentBallot.counter);
        Slot slot = mSlot;
        mSlot.getCPDriver().setupTimer(mSlot.getSlotIndex(),
                Slot.BALLOT_PROTOCOL_TIMER, timeout, () {
                    mSlot.getBallotProtocol().ballotProtocolTimerExpired();
                });
    }

}
